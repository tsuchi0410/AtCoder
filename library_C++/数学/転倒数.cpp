/*

転倒数
概要:
昇順ソートされているはずの数列で正しい順序になってないペアの数
{1, 2, 3, 4, 5} の転倒数は 0
{1, 2, 3, 5, 4} の転倒数は 1
{5, 1, 2, 3, 4} の転倒数は 4

バブルソートの交換回数と一致
愚直に求めると O(N^2) だが区間和のセグ木を用いて O(NlogN) で求められる

手順:
1. 出席を取る
table:最初の状態
 A:	8	3	6	5	2	4	1	9	7
 BIT:									

table:8が出てきたのでBITの8番目に1を足した
 A:	|8|	3	6	5	2	4	1	9	7
 BIT:								1	

table:3が出てきたのでBITの3番目に1を足した
 A:	8	|3|	6	5	2	4	1	9	7
 BIT:			1					1	

table:6が出てきたのでBITの6番目に1を足した
 A:	8	3	|6|	5	2	4	1	9	7
 BIT:			1			1		1	

table:5が出てきたのでBITの5番目に1を足した
 A:	8	3	6	|5|	2	4	1	9	7
 BIT:			1		1	1		1	

table:2が出てきたのでBITの2番目に1を足した
 A:	8	3	6	5	|2|	4	1	9	7
 BIT:		1	1		1	1		1

ここで、 4 について考えるとき、 index で 4 より右にある区間和が 4 について考えたときの転倒数
これをすべての数に対して行う

*/

int main(){
  LL(N);
  VEC(ll, a, N);
  vector<ll> v(N);
  SegmentTree<ll> seg(v, [&](ll a, ll b){ return a + b; }, 0);
  ll cnt = 0;
  rep(i, N){
    cnt += seg.prod(a[i], N);
    seg.set(a[i] - 1, 1);
  }
  print(cnt);
}
◯セグメント木の概要
・完全二分木（全ての葉の深さが等しい木）によって実装された、区間を扱うのに適したデータ構造

◯セグメント木でできること
-> 区間に対する操作やクエリを行うことができる
・区間上の値を更新する(log n)
・任意の区間上の最小値や合計値を取得する(log n)
区間上の合計値などは、累積和などを使えば前処理 O(N) ・クエリ O(1) で取得することもできる
しかし、区間上の値の更新と、合計値の取得が入り乱れるような時は、セグメント木の方が有効になることが多い

◯使い方(https://qiita.com/takayg1/items/c811bd07c21923d7ec69)
◎設定
1. 初期化用のリストを用意する
a = [14, 5, 9, 13, 7, 12, 11, 1, 7, 8]

2. 区間に行う操作を決める
・最小値 : min(x, y), 単位元 : float("inf")
・最大値 : max(x, y), -float("inf")
・区間和 : x + y, 0
・区間積 : x * y, 1
・最大公約数 : math.gcd(x, y), 0
def segfunc(x, y):
    return min(x, y)

3. 単位元を定める
初期化に使う。最小値なら、
ide_ele = float('inf')

4. オブジェクトを作成
引数は上の3つ(リスト, 区間に行う操作, 単位元)
seg = SegTree(a, segfunc, ide_ele)

◎操作
1. ある1つの要素の更新 (1 - indexed)
update(k, x) : k 番目の要素を x に更新

2. ある区間の操作の結果を取得
query(l, r) : [l, r)(l以上r未満の区間)から値を取得

# [0, 8)の最小値を表示
print(seg.query(0, 8)) # 1

# 5番目を0に変更
seg.update(5, 0)

# [0, 8)の最小値を表示
print(seg.query(0, 8)) # 0
